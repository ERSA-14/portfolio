# -*- coding: utf-8 -*-
"""DS006.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HkJpFgS0uRCh4COmih84S1qlX_2y9Av1

As i cant find any way to access full facebook database , as i can only get info related to my account using facebook Api , so we will create a new datset randomly.
"""

!pip install anytree

import anytree
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import random
import networkx as nx
from sklearn.tree  import DecisionTreeClassifier
from sklearn.ensemble import AdaBoostClassifier, VotingClassifier, GradientBoostingClassifier

from anytree import Node, RenderTree
from anytree.exporter import DotExporter
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.tree import plot_tree
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import (
    accuracy_score,
    classification_report,
    confusion_matrix,
    roc_curve,
    roc_auc_score
)

# to generate random Name
def generate_name(gender='M', father_name=None):
    first_names_male = ['Saksham', 'Vivan', 'Aditya', 'Rahul']
    first_names_female = ['Kirti', 'Saanvi', 'Priya', 'Ananya']
    last_names = ['Sharma', 'Patel', 'Bansal', 'Singh', 'Gupta', 'Jha']

    # Select first name based on gender
    first_name = random.choice(first_names_male if gender == 'M' else first_names_female)

    # If father_name is provided, inherit the surname from the father
    last_name = father_name.split()[-1] if father_name else random.choice(last_names)

    return f"{first_name} {last_name}"





# Create a list to store family data
family_data = []

# Generation 1
father1_name = generate_name('M')
father2_name = generate_name('M')
mother1_name = generate_name('F')
mother2_name = generate_name('F')

# Add both parents
family_data.append([1, father1_name, None, None])  # Father 1
family_data.append([2, mother1_name, None, None])  # Mother 1
family_data.append([3, father2_name, None, None])  # Father 2
family_data.append([4, mother2_name, None, None])  # Mother 2

#to track children of Generation 1
children_data_gen1 = []


# Maximum number of children per parent
max_children = 3
children_count = {1: 0, 2: 0, 3: 0, 4: 0}  # Track number of children







# Generation 1 children
for i in range(5, 11):
    father_id = random.choice([1, 3])  # Randomly choose between father1 and father2
    mother_id = random.choice([2, 4])  # Randomly choose between mother1 and mother2

    # Ensure that no parent has more than 3 children
    if children_count[father_id] < max_children and children_count[mother_id] < max_children:

        # Get the father's name from the family data (find the parent by father_id)
        father_name = next(name for fid, name, _, _ in family_data if fid == father_id)

        name = generate_name('M' if i % 2 == 0 else 'F', father_name)  # Name based on gender and father's surname

        family_data.append([i, name, father_id, mother_id])
        children_data_gen1.append(i)
        children_count[father_id] += 1
        children_count[mother_id] += 1






# Add children for Generation 2
children_data_gen2 = []
for i in range(11, 17):
    father_id = random.choice(children_data_gen1)  # Randomly select father from Generation 1 children

    # Ensure mother_id is not the same as father_id
    mother_id = random.choice([x for x in children_data_gen1 if x != father_id])  # Randomly select mother but not the same as father

    # Ensure no parent has more than 3 children
    children_count[father_id] = children_count.get(father_id, 0)  # Initialize if not present
    children_count[mother_id] = children_count.get(mother_id, 0)  # Initialize if not present

    if children_count[father_id] < max_children and children_count[mother_id] < max_children:
        # Get the father's name from the family data
        father_name = next(name for fid, name, _, _ in family_data if fid == father_id)
        name = generate_name('M' if i % 2 == 0 else 'F', father_name)  # Name based on father's surname

        family_data.append([i, name, father_id, mother_id])
        children_data_gen2.append(i)
        children_count[father_id] += 1
        children_count[mother_id] += 1






# Add children for Generation 3
children_data_gen3 = []
for i in range(17, 23):
    father_id = random.choice(children_data_gen2)  # Randomly select father from Generation 2

    # Ensure mother_id is not the same as father_id
    mother_id = random.choice([x for x in children_data_gen2 if x != father_id])  # Randomly select mother but not the same as father

    # Ensure no parent has more than 3 children
    children_count[father_id] = children_count.get(father_id, 0)  # Initialize if not present
    children_count[mother_id] = children_count.get(mother_id, 0)  # Initialize if not present

    if children_count[father_id] < max_children and children_count[mother_id] < max_children:
        # Get the father's name from the family data (find the parent by father_id)
        father_name = next(name for fid, name, _, _ in family_data if fid == father_id)
        name = generate_name('M' if i % 2 == 0 else 'F', father_name)  # Name based on father's surname

        family_data.append([i, name, father_id, mother_id])
        children_data_gen3.append(i)
        children_count[father_id] += 1
        children_count[mother_id] += 1







# Add children for Generation 4
children_data_gen4 = []
for i in range(23, 29):
    father_id = random.choice(children_data_gen3)  # Randomly select father from Generation 3

    # Ensure mother_id is not the same as father_id
    mother_id = random.choice([x for x in children_data_gen3 if x != father_id])  # Randomly select mother but not the same as father

    # Ensure no parent has more than 3 children
    children_count[father_id] = children_count.get(father_id, 0)  # Initialize if not present
    children_count[mother_id] = children_count.get(mother_id, 0)  # Initialize if not present

    if children_count[father_id] < max_children and children_count[mother_id] < max_children:
        # Get the father's name from the family data (find the parent by father_id)
        father_name = next(name for fid, name, _, _ in family_data if fid == father_id)
        name = generate_name('M' if i % 2 == 0 else 'F', father_name)  # Name based on father's surname

        family_data.append([i, name, father_id, mother_id])
        children_data_gen4.append(i)
        children_count[father_id] += 1
        children_count[mother_id] += 1









# Add children for Generation 5
for i in range(29, 35):
    father_id = random.choice(children_data_gen4)  # Randomly select father from Generation 4

    # Ensure mother_id is not the same as father_id
    mother_id = random.choice([x for x in children_data_gen4 if x != father_id])  # Randomly select mother but not the same as father

    # Ensure no parent has more than 3 children
    children_count[father_id] = children_count.get(father_id, 0)  # Initialize if not present
    children_count[mother_id] = children_count.get(mother_id, 0)  # Initialize if not present

    if children_count[father_id] < max_children and children_count[mother_id] < max_children:
        # Get the father's name from the family data (find the parent by father_id)
        father_name = next(name for fid, name, _, _ in family_data if fid == father_id)
        name = generate_name('M' if i % 2 == 0 else 'F', father_name)  # Name based on father's surname

        family_data.append([i, name, father_id, mother_id])
        children_count[father_id] += 1
        children_count[mother_id] += 1






print(f"Total number of entries: {len(family_data)}")

# Create DataFrame
df = pd.DataFrame(family_data, columns=["ID", "Name", "Father_ID", "Mother_ID"])

# Save the file to CSV
df.to_csv('gene.csv', index=False)

# Display the first few rows to confirm
print(df.head())

"""Now lets Visualize our data"""

!apt-get install -y graphviz libgraphviz-dev pkg-config
!pip install pygraphviz==1.14 --force-reinstall --no-cache-dir

import pygraphviz as pgv

# Load the data
df = pd.read_csv('/content/gene.csv')

# Create a directed graph for the family tree
G = nx.DiGraph()

# Add nodes and edges from the DataFrame
for _, row in df.iterrows():
  # used _ because there is no index

    person_id = row['ID']
    name = row['Name']
    father_id = row['Father_ID']
    mother_id = row['Mother_ID']

    # Add the node

    G.add_node(person_id, label=name)

    # Add edges for father and mother
    # .notna return true if the value is not NaN


    if pd.notna(father_id):  # Only add the edge if father_id is not NaN
        G.add_edge(father_id, person_id)

    if pd.notna(mother_id):  # Only add the edge if mother_id is not NaN
        G.add_edge(mother_id, person_id)


# Define a tree layout for the graph
# parents at the top, children at the bottom


pos = nx.nx_agraph.graphviz_layout(G, prog="dot")  # "dot" creates a hierarchical layout
#nx.nx_agraph.graphviz_layout(): is used to compute the layout for a graph G



# Plot the family tree

plt.figure(figsize=(12, 8))


# Giving color and design

nx.draw(G, pos, with_labels=True, labels=nx.get_node_attributes(G, 'label'),
        node_size=3000, node_color="yellow", font_size=10, font_weight='bold',
        width=2, edge_color="gray")




# Show the plot
plt.show()

class DiseaseInheritancePredictionModel:

    def __init__(self, csv_file, save_features=False, features_output_file=None):


        self.data = pd.read_csv(csv_file)


        # Print available columns for debugging
        print("Available columns:", list(self.data.columns))


        # Validate required columns
        required_columns = ['ID', 'Name', 'Father_ID', 'Mother_ID']
        missing_columns = [col for col in required_columns if col not in self.data.columns]


        if missing_columns:
            raise ValueError(f"Missing required columns: {missing_columns}")


        # Preprocess data
        self._preprocess_data()


        # Save features to a CSV file if requested
        if save_features and features_output_file:
            self.save_engineered_features(features_output_file)





    def _preprocess_data(self):

        # Create feature engineering
        self.features = self._engineer_features()

        # Simulate disease status if not present
        if 'disease_status' not in self.features.columns:
            np.random.seed(42)
            self.features['disease_status'] = self._simulate_disease_inheritance()





    def _engineer_features(self):

        features = self.data.copy()

        # Handle categorical variables
        le = LabelEncoder()


        # Create genetic relationship features
        features['has_father'] = features['Father_ID'].notna().astype(int)
        features['has_mother'] = features['Mother_ID'].notna().astype(int)


        # Calculate family size
        father_counts = features['Father_ID'].value_counts()
        mother_counts = features['Mother_ID'].value_counts()

        features['father_children_count'] = features['Father_ID'].map(father_counts).fillna(0)
        features['mother_children_count'] = features['Mother_ID'].map(mother_counts).fillna(0)

        features['total_siblings'] = features['father_children_count'] + features['mother_children_count'] - 1


        # Age-related features
        np.random.seed(42)
        features['age'] = np.random.randint(18, 120, size=len(features))


        # Genetic diversity features
        features['genetic_diversity_score'] = np.random.random(len(features))


        # Encode name if needed
        features['name_encoded'] = le.fit_transform(features['Name'])


        return features





    def save_engineered_features(self, output_file):

        # Save the engineered features DataFrame to a CSV file

        self.features.to_csv(output_file, index=False)
        print(f"Engineered features saved to: {output_file}")





    def _simulate_disease_inheritance(self):

        # Initialize disease status
        disease_status = np.zeros(len(self.features), dtype=int)


        # Base probability of disease
        base_prob = 0.25


        # Genetic inheritance factors
        for i in range(len(self.features)):



            # Check parental disease status
            father_infected = self.features.loc[
                self.features['ID'] == self.features.loc[i, 'Father_ID'],
                'disease_status'
            ].values if 'disease_status' in self.features.columns else []


            mother_infected = self.features.loc[
                self.features['ID'] == self.features.loc[i, 'Mother_ID'],
                'disease_status'
            ].values if 'disease_status' in self.features.columns else []



            # Calculate inheritance probability
            inheritance_prob = base_prob



            # Increase probability if parents are infected
            if len(father_infected) > 0 and father_infected[0] == 1:
                inheritance_prob += 0.5
            if len(mother_infected) > 0 and mother_infected[0] == 1:
                inheritance_prob += 0.5



            # Add some randomness and age-related risk
            age_risk = (self.features.loc[i, 'age'] - 18) / 69  # Normalize age risk
            inheritance_prob += age_risk * 0.2

            # Determine disease status
            disease_status[i] = 1 if np.random.random() < min(inheritance_prob, 0.9) else 0


        return disease_status






    def train_random_forest(self, test_size=0.2, random_state=42):


        if 'disease_status' not in self.features.columns:
            self.features['disease_status'] = self._simulate_disease_inheritance()



        exclude_columns = ['ID', 'Name', 'Father_ID', 'Mother_ID', 'disease_status']
        X = self.features.drop(columns=[col for col in exclude_columns if col in self.features.columns])
        y = self.features['disease_status']




        # Split the data
        from sklearn.model_selection import train_test_split
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=random_state)




        # Scale features
        from sklearn.preprocessing import StandardScaler
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)




        # Train
        from sklearn.ensemble import RandomForestClassifier
        rf_model = RandomForestClassifier(n_estimators=210, random_state=random_state, n_jobs=-1)
        rf_model.fit(X_train_scaled, y_train)




        # Make predictions
        y_pred = rf_model.predict(X_test_scaled)




        # Evaluate the model
        from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
        accuracy = accuracy_score(y_test, y_pred)
        report = classification_report(y_test, y_pred)
        confusion = confusion_matrix(y_test, y_pred)





        # Feature importance
        feature_importance = pd.DataFrame({
            'feature': X.columns,
            'importance': rf_model.feature_importances_
        }).sort_values('importance', ascending=True)





        # Visualize feature importance
        plt.figure(figsize=(10, 6))
        feature_importance.plot(x='feature', y='importance', kind='bar')
        plt.xlabel('Features')
        plt.ylabel('Importance')
        plt.tight_layout()
        plt.show()




        # Visualize
        plt.figure(figsize=(8, 6))
        y.value_counts().plot(kind='pie', autopct='%1.1f%%', labels=['Unaffected', 'Affected'], colors=['green', 'red'])
        plt.title('Disease Distribution')
        plt.show()


        return {
            'accuracy': accuracy,
            'classification_report': report,
            'confusion_matrix': confusion,
            'feature_importance': feature_importance
        }



def main():


    csv_file = input("Enter the path to your CSV file: ")
    save_features = input("Do you want to save the engineered features? (y/n): ").lower() == 'y'
    features_output_file = None


    if save_features:

        features_output_file = input("Enter the path to save the engineered features (e.g., features.csv): ")

    try:

        model = DiseaseInheritancePredictionModel(csv_file, save_features, features_output_file)

        results = model.train_random_forest()


        # Display results
        print("\nRandom Forest Results:")
        print(f"Accuracy: {results['accuracy']}")
        print("\nClassification Report:")
        print(results['classification_report'])
        print("\nConfusion Matrix:")
        print(results['confusion_matrix'])
        print("\nFeature Importance:")
        print(results['feature_importance'])


    except ValueError as e:
        print(f"Error: {e}")
    except FileNotFoundError:
        print("Error: The specified file was not found.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")


if __name__ == "__main__":
    main()

class RScoreCalculator:


    def __init__(self, csv_file):

        # Load the dataset
        self.data = pd.read_csv('/content/gene.csv')

        # Preprocess and engineer features
        self._preprocess_data()

        # Add disease status column
        self._add_disease_status()



    def _preprocess_data(self):

        # Ensure numeric columns
        numeric_cols = ['ID', 'Father_ID', 'Mother_ID']
        for col in numeric_cols:
            self.data[col] = pd.to_numeric(self.data[col], errors='coerce')


        # Remove invalid rows
        self.data.dropna(subset=['ID'], inplace=True)


        # Feature engineering
        le = LabelEncoder()



        # Create genetic relationship features
        self.data['has_father'] = self.data['Father_ID'].notna().astype(int)
        self.data['has_mother'] = self.data['Mother_ID'].notna().astype(int)


        # Calculate family statistics
        father_counts = self.data['Father_ID'].value_counts()
        mother_counts = self.data['Mother_ID'].value_counts()

        self.data['father_children_count'] = self.data['Father_ID'].map(father_counts).fillna(0)
        self.data['mother_children_count'] = self.data['Mother_ID'].map(mother_counts).fillna(0)
        self.data['total_siblings'] = self.data['father_children_count'] + self.data['mother_children_count'] - 1



        # Name encoding
        self.data['name_encoded'] = le.fit_transform(self.data['Name'])



        # Age and genetic diversity
        np.random.seed(42)
        self.data['age'] = np.random.randint(18, 120, size=len(self.data))
        self.data['genetic_diversity_score'] = np.random.random(len(self.data))





    def _add_disease_status(self):

        # Simulate disease status based on engineered features
        np.random.seed(42)
        self.data['disease_status'] = np.where(
            (self.data['age'] > 50) &
            (self.data['total_siblings'] > 2) &
            (self.data['genetic_diversity_score'] < 0.5),
            1, 0
        )





    def calculate_r_score(self):

        # Select numeric columns
        numeric_columns = self.data.select_dtypes(include=[np.number])

        # Compute correlation matrix
        correlation_matrix = numeric_columns.corr()

        # Extract correlations with disease status
        disease_correlations = correlation_matrix['disease_status'].abs().sort_values(ascending=False)

        return disease_correlations




    def visualize_correlation_matrix(self):

        # Select numeric columns
        numeric_columns = self.data.select_dtypes(include=[np.number])

        # Compute correlation matrix
        correlation_matrix = numeric_columns.corr()

        # Create heatmap
        plt.figure(figsize=(12, 10))
        sns.heatmap(correlation_matrix,
                    annot=True,
                    cmap='coolwarm',
                    center=0,
                    linewidths=0.5,
                    fmt='.2f',
                    square=True)

        plt.tight_layout()
        plt.show()



    def generate_r_score_report(self):

        # Calculate R-Scores
        r_scores = self.calculate_r_score()

        print("\nTop Correlated Features:")
        print(r_scores[r_scores > 0])

        print("\nFeature Importance Ranking:")
        for feature, score in r_scores[r_scores > 0].items():
            print(f"{feature}: {score:.4f}")

        return r_scores




if __name__ == "__main__":
    try:

        # Create the R-Score Calculator
        r_score_calculator = RScoreCalculator('/content/gene.csv')

        # Generate R-Score Report
        r_scores = r_score_calculator.generate_r_score_report()

        # Visualize Correlation Matrix
        r_score_calculator.visualize_correlation_matrix()


    except Exception as e:
        print(f"An error occurred: {e}")

!pip install scikit-learn

from sklearn.preprocessing import MinMaxScaler

class DiseaseInheritanceModel:


    def __init__(self, csv_file):

        try:
            # Load the CSV file
            self.data = pd.read_csv(csv_file)

            # Validate required columns
            required_columns = ['ID', 'Name', 'Father_ID', 'Mother_ID']
            missing_columns = [col for col in required_columns if col not in self.data.columns]

            if missing_columns:
                raise ValueError(f"Missing required columns: {missing_columns}")

            # Preprocess and engineer features
            self._preprocess_data()

            # Create family graph
            self._create_family_graph()

            # Initialize tracking variables
            self.disease_probabilities = {}
            self.inheritance_log = []


            # Detailed feature importance weights
            self.feature_weights = {
                'age': 0.366661,
                'total_siblings': 0.101650,
                'mother_children_count': 0.155828,
                'name_encoded': 0.140623,
                'genetic_diversity_score': 0.148836,
                'father_children_count': 0.064572,
                'has_mother': 0.017174,
                'has_father': 0.004656
            }


            # Initialize scaler for feature normalization
            self.scaler = MinMaxScaler()

        except Exception as e:
            print(f"Model Initialization Error: {e}")
            raise





    def _preprocess_data(self):

        # Ensure numeric columns
        numeric_cols = ['ID', 'Father_ID', 'Mother_ID']
        for col in numeric_cols:
            self.data[col] = pd.to_numeric(self.data[col], errors='coerce')

        # Remove invalid rows
        self.data.dropna(subset=['ID'], inplace=True)

        # Feature engineering
        le = LabelEncoder()

        # Create genetic relationship features
        self.data['has_father'] = self.data['Father_ID'].notna().astype(int)
        self.data['has_mother'] = self.data['Mother_ID'].notna().astype(int)

        # Calculate family statistics
        father_counts = self.data['Father_ID'].value_counts()
        mother_counts = self.data['Mother_ID'].value_counts()

        self.data['father_children_count'] = self.data['Father_ID'].map(father_counts).fillna(0)
        self.data['mother_children_count'] = self.data['Mother_ID'].map(mother_counts).fillna(0)
        self.data['total_siblings'] = self.data['father_children_count'] + self.data['mother_children_count'] - 1

        # Name encoding
        self.data['name_encoded'] = le.fit_transform(self.data['Name'])

        # Age and genetic diversity
        np.random.seed(42)
        self.data['age'] = np.random.randint(18, 120, size=len(self.data))
        self.data['genetic_diversity_score'] = np.random.random(len(self.data))






    def _create_family_graph(self):


        self.family_graph = nx.DiGraph()

        for _, row in self.data.iterrows():
            node_id = int(row['ID'])



            # Add node with comprehensive attributes
            self.family_graph.add_node(node_id,
                                       name=row['Name'],
                                       age=row['age'],
                                       total_siblings=row['total_siblings'],
                                       father_children_count=row['father_children_count'],
                                       mother_children_count=row['mother_children_count'],
                                       name_encoded=row['name_encoded'],
                                       genetic_diversity_score=row['genetic_diversity_score'],
                                       has_father=row['has_father'],
                                       has_mother=row['has_mother'])




            # Add parent-child edges
            if pd.notna(row['Father_ID']):
                father_id = int(row['Father_ID'])
                self.family_graph.add_edge(father_id, node_id)

            if pd.notna(row['Mother_ID']):
                mother_id = int(row['Mother_ID'])
                self.family_graph.add_edge(mother_id, node_id)




    def calculate_inheritance_probability(self, initial_infected_nodes, base_inheritance_rate=0.5):


        # Reset probabilities
        self.disease_probabilities = {}
        self.inheritance_log = []


        # Normalize features
        normalized_data = self.data.copy()
        for feature in self.feature_weights.keys():
            if feature in normalized_data.columns:
                normalized_data[feature] = self.scaler.fit_transform(normalized_data[[feature]])


        # Mark initial infected nodes
        for node_id in initial_infected_nodes:
            if node_id in self.family_graph.nodes():
                self.disease_probabilities[node_id] = 1.0


        # Propagate inheritance probabilities
        for node in self.family_graph.nodes():
            if node not in self.disease_probabilities:
                # Get parent probabilities
                parent_probs = [self.disease_probabilities.get(parent, 0)
                                for parent in self.family_graph.predecessors(node)]



                if parent_probs:
                    # Base probability from parents
                    base_prob = np.mean(parent_probs) * base_inheritance_rate



                    # Apply feature-based modifiers
                    node_attrs = self.family_graph.nodes[node]
                    prob_modifiers = [
                        self.feature_weights['age'] * node_attrs['age'] / 80, #we have set age to max 80
                        self.feature_weights['total_siblings'] * node_attrs['total_siblings'] / 6,
                        self.feature_weights['mother_children_count'] * node_attrs['mother_children_count'] / 3,
                        self.feature_weights['name_encoded'] * node_attrs['name_encoded'] / 40,
                        self.feature_weights['genetic_diversity_score'] * node_attrs['genetic_diversity_score'],
                        self.feature_weights['father_children_count'] * node_attrs['father_children_count'] / 10,
                        self.feature_weights['has_mother'] * node_attrs['has_mother'],
                        self.feature_weights['has_father'] * node_attrs['has_father']
                    ]


                    final_prob = base_prob * (1 + sum(prob_modifiers))
                    self.disease_probabilities[node] = min(max(final_prob, 0), 1)


        return self.disease_probabilities





    def generate_inheritance_report(self):

        report = pd.DataFrame.from_dict(self.disease_probabilities, orient='index', columns=['Inheritance Probability'])
        report['Name'] = [self.family_graph.nodes[node]['name'] for node in report.index]
        report = report.sort_values('Inheritance Probability', ascending=False)


        print(report)




    def plot_family_graph(self):

        plt.figure(figsize=(15, 10))

        # Create a hierarchical layout using Graphviz
        pos = nx.nx_agraph.graphviz_layout(self.family_graph, prog="dot")


        # Draw the graph

        nx.draw(self.family_graph, pos,
                node_color=[self.disease_probabilities.get(node, 0) for node in self.family_graph.nodes()],
                cmap=plt.cm.YlOrRd,
                node_size=650,
                with_labels=False,
                arrows=True)



        # Add labels with names and probabilities

        for node, (x, y) in pos.items():
            prob = self.disease_probabilities.get(node, 0)
            name = self.family_graph.nodes[node]['name']
            plt.text(x, y + 0.1, f"{name}\nProb: {prob:.2f}",
                     horizontalalignment='center',
                     verticalalignment='bottom',
                     fontsize=10)

        plt.show()




if __name__ == "__main__":

    model = DiseaseInheritanceModel('/content/gene.csv')


    initial_infected = [1]  # Example initial infected nodes

    # Calculate probabilities
    probabilities = model.calculate_inheritance_probability(initial_infected)

    # Generate report
    model.generate_inheritance_report()

    # Plot the family graph
    model.plot_family_graph()